function PowerOffOn(firma, power) {                 //родительская
    this.firma = firma;                
    this.power = power;
    this.status = false;
    this.priboron = function() {
    console.log(this.firma + " On!");
    this.status = true;
	};
	this.priboroff = function() {
    console.log(this.firma + " Off");
    this.status = false;
	};
}


function Lampa (firma, power) {                            //лампа
    this.firma = firma;
    this.power = power;
}

function PC (firma, power) {                                  // РС
    this.firma = firma;
    this.power = power;
}


Lampa.prototype = new PowerOffOn();                            //делигирующая связь
PC.prototype = new PowerOffOn();

const homeLampa = new Lampa("Delta", 50);                       //экземпляры
const notebook = new PC ("Acer", 250);

homeLampa.priboroff();
notebook.priboron();

console.log("состояние приборов:");
console.log(homeLampa);
console.log(notebook);
console.log(`Сммарная мощность приборов составляет - ${homeLampa.power + notebook.power} W`)

//Задание 4
//
//Реализовать следующее консольное приложение подобно примеру, который разбирался в видео. 
//Реализуйте его на прототипах.
//
//Определить иерархию электроприборов. Включить некоторые в розетку. 
//Посчитать потребляемую мощность. 
//
//Таких приборов должно быть, как минимум, два (например, настольная лампа и компьютер). 
//Выбрав прибор, подумайте, какими свойствами он обладает.
//
//План:
//
//Определить родительскую функцию с методами, которые включают/выключают прибор из розетки.+
//Создать делегирующую связь [[Prototype]] для двух конкретных приборов.+
//У каждого из приборов должны быть собственные свойства и, желательно, методы, отличные от родительских методов.+
//Создать экземпляры каждого прибора.+
//Вывести в консоль и посмотреть результаты работы, гордиться собой :)+
//Общие требования:
//
//Имена функций, свойств и методов должны быть информативными
//Соблюдать best practices:
//использование camelCase нотации для переменных и методов, PascalCase — для названий функций-конструкторов и классов;
//информативные имена;
//четкая связь между классом и его экземплярами (класс описывает множество, а экземпляр конкретную реализацию);
//использование синтаксиса ES6 (кроме функции-конструкторов) и т.д.

